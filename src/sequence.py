# Cosmic View of Life on Earth

# Author: Brian Abbott <abbott@amnh.org>
# Created: September 2022
"""
Process the DNA sequence data, which has many points per species. This combines the metadata dataframe and results in one speck file for the sequence data. Labels and colors are generated by the :file:`sequence_lineage.py` script.
"""

import sys
import re
import pandas as pd
from pathlib import Path

from src import common


def process_data(datainfo, metadata):
    """
    Process the sequence data.

    :param datainfo: Metadata about the dataset.
    :type datainfo: dict of {str : list}
    :param metadata: A table with all the lineage metadata of that order of species.
    :type metadata: DataFrame
    :return: A table of DNA sample data for each sequence.
    :rtype: DataFrame


    We combine the sequence data, the seq2taxon info, the metadata, and the synonomous data (if available), to output one speck file and one label file for each lineage column within the specified range. That range usually begins at the "Class" level (Aves, Primates, etc.) which is the last column that all data point share.

    Output files:
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    :file:`[{order}]/[{version}]/sequences/sequences.speck`
        The OpenSpace-ready file for the DNA sequence data.
    
    :file:`[{order}]/[{version}]/sequences/sequences_taxon.cmap`
        The OpenSpace-ready file for the DNA sequence data.

    :file:`catalogs_processed/[{order}]/{version}/sequences.csv`
        The CSV file for the complete DNA sequence data and metadata.
    """

    common.print_subhead_status('Processing DNA sequence data')

    datainfo['data_group_title'] = datainfo['sub_project'] + ': DNA sequence data'
    datainfo['data_group_desc'] = 'DNA sample data for primates. Each point represents one DNA sample.'



    # Read the sequence file and process into a dataframe
    # ---------------------------------------------------------------------------
    inpath = Path.cwd() / common.DATA_DIRECTORY / datainfo['dir'] / datainfo['catalog_directory'] / datainfo['sequence_file']
    common.test_input_file(inpath)

    seq = pd.read_csv(inpath)
    seq.columns = ['seq_id', 'x', 'y', 'z']


    # Read the sequence-to-taxon file and process into a dataframe
    # ---------------------------------------------------------------------------
    inpath_seq2taxon = Path.cwd() / common.DATA_DIRECTORY / datainfo['dir'] / datainfo['catalog_directory'] / datainfo['seq2taxon_file']
    common.test_input_file(inpath_seq2taxon)

    seq2taxon = pd.read_csv(inpath_seq2taxon, sep=';', header=None, names=['seq_id', 'Taxon'])

    # Coalate the seq2taxon data with the main seqence dataframe
    seq = pd.merge(seq, seq2taxon, left_on='seq_id', right_on='seq_id', how='left')

    # Rearrange the columns
    seq = seq[['x', 'y', 'z', 'seq_id', 'Taxon']]
        
    
    # # ---- This is here in case we don't want to pass the metadata info, but read it from the CSV file
    # # Open the metadata CSV file, generated by metadata.py, and save it into a df
    # inpath_metadata = Path.cwd() / common.DATA_DIRECTORY / datainfo['dir'] / common.PROCESSED_DATA_DIRECTORY / 'metadata.csv'
    # common.test_input_file(inpath_metadata)
    # metadata = pd.read_csv(inpath_metadata)


    # Merge the info from the 'metadata' dataframe (lineage info)
    df = pd.merge(seq, metadata, left_on='Taxon', right_on='taxon', how='left').drop('Taxon', axis=1)

    # Open the synonomous/non-synonomous data file to merge that info
    # only if the value of the datainfo is not None
    if datainfo['synonomous_file'] is not None:
        
        inpath_synonomous = Path.cwd() / common.DATA_DIRECTORY / datainfo['dir'] / datainfo['catalog_directory'] / datainfo['synonomous_file']
        common.test_input_file(inpath_synonomous)

        syn_init = pd.read_csv(inpath_synonomous)

        # Split the |-separated lineage column in the CSV file into its
        # own dataframe so we can process it separately.
        split_cols = syn_init['seqId'].str.split('|', expand=True)

        # Rename some of the columns
        split_cols = split_cols.rename(columns = {0:'seq', 1:'taxon', 2:'col3', 3:'col4'})

        # Save the dataframe into a new dataframe
        synonomous = syn_init.join(split_cols)

        # Drop these columns, we don't need them
        synonomous.drop(['seqId', 'taxon', 'col3', 'col4'], axis=1, inplace=True)

        # Merge the synonomous data with the main df, and drop the duplicate columns
        df = pd.merge(df, synonomous, left_on='seq_id', right_on='seq', how='left').drop('seq', axis=1)


        # If there are a few items from the main data that do not have synonomous data
        # we set the missing values to zero. We want to maintain NaN in other columns though,
        # so we set it for specific columns only
        df[['synonymousDiff', 'NonSynonymousDiff']] = df[['synonymousDiff', 'NonSynonymousDiff']].fillna(value=0)


    
    # Rescale the position data
    df['x'] = df['x'].multiply(common.POSITION_SCALE_FACTOR)
    df['y'] = df['y'].multiply(common.POSITION_SCALE_FACTOR)
    df['z'] = df['z'].multiply(common.POSITION_SCALE_FACTOR)


    # Assign a taxon code    
    taxon_list = df['taxon'].unique()
    taxon_code_list = list(enumerate(taxon_list, start=1))

    # Join the taxon list and codes into a DataFrame
    unique_taxons = pd.DataFrame(taxon_code_list, columns=['taxon_code', 'taxon'])

    # Merge the taxon_code into the main sequence df
    df = pd.merge(df, unique_taxons, left_on='taxon', right_on='taxon', how='left')



    # Construct the .speck and .label columns
    df.loc[df['taxon'].notnull(), 'speck_name'] = df['seq_id'] + ' | ' + df['taxon']
    df.loc[df['taxon'].isnull(), 'speck_name'] = df['seq_id']



    # Add color info to the unique_taxons df. 
    # This way we assign a color to each taxon_code.
    # ---------------------------------------------------------------------------
    # Read in the crayola.dat
    inpath = Path.cwd() / common.PROCESSED_DATA_DIRECTORY / common.COLOR_DIRECTORY / 'crayola' / 'crayola.dat'

    # Function reads the color table file, generates a df of colors
    # with as many entries from the length passed.
    color_df = common.parse_color_file(inpath, len(unique_taxons))

    # Merge the list of taxons and taxon codes with the colors,
    # matching on the color index and taxon code.
    unique_taxons = pd.merge(unique_taxons, color_df, left_on='taxon_code', right_on='color_index', how='left')


    # Print this to a csv file
    outpath_taxon_csv = Path.cwd() / common.PROCESSED_DATA_DIRECTORY / datainfo['dir']
    common.test_path(outpath_taxon_csv)

    #outfile_csv = datainfo['dir'] + '.csv'
    outfile_taxon_csv = 'taxon_codes.csv'
    outpath_taxon_csv = outpath_taxon_csv / outfile_taxon_csv

    unique_taxons.to_csv(outpath_taxon_csv, columns=['taxon_code', 'taxon'], index=False)
    common.out_file_message(outpath_taxon_csv)






    # Print the speck file
    # --------------------------------------------------------------------------
    out_file_stem = 'sequences'
    outpath = Path.cwd() / datainfo['dir'] / datainfo['catalog_directory'] / common.SEQUENCE_DIRECTORY
    common.test_path(outpath)

    outfile_speck = out_file_stem + '.speck'
    outpath_speck = outpath / outfile_speck
    with open(outpath_speck, 'wt') as speck:

        header = common.header(datainfo, script_name=Path(__file__).name)
        print(header, file=speck)

        # Print the 'datavar' columns.
        # Make a list of the column names we want to print in the speck file
        # This is the initial list, then we add the required lineage columns
        # If we have synonomous columns (the synonomous file exists), include those columns
        if datainfo['synonomous_file'] is not None:
            cols_to_print = ['taxon_code', 'hybrid', 'synonymousDiff', 'NonSynonymousDiff']
        else:
            cols_to_print = ['taxon_code', 'hybrid']
        
        # Add the lineage columns that are in the range we want.
        # Cycle through the sequence df
        for column_name in df.columns:
            
            # If we match a "lineage_*_code" column
            if re.match(r'^(lineage_)([0-9]+)(_code)$', column_name):

                # Extract the integer from the lineage column number
                lineage_col_number = int(re.search(r'\d+', column_name).group())

                # if the lineage column number is in the range we want,
                # then add the column name to the list
                if(lineage_col_number in range(datainfo['lineage_columns'][0], datainfo['lineage_columns'][1] + 1)):
                    cols_to_print.append(column_name)
                

        # set a counter for the datavar number, and cycle through the
        # columns to print list and print the datavar lines
        i = 0
        for col in cols_to_print:
            print('datavar ' + str(i) + ' ' + col, file=speck)
            i += 1

        
        # Print the rows to the speck file
        for col, row in df.iterrows():

            # Print the x,y,z
            print(f"{row['x']:.8f} {row['y']:.8f} {row['z']:.8f}", file=speck, end ='')

            # Print the data for the columns in the selected columns in cols_to_print
            for column in cols_to_print:
                print(f" {row[column]}", file=speck, end ='')
            
            # Print the speck label commented at the end of the line
            print(f" # {row['speck_name']}", file=speck)

    common.out_file_message(outpath_speck)

        
        
    # Print data to a CSV file
    # --------------------------------------------------------------------------
    outpath_csv = Path.cwd() / common.PROCESSED_DATA_DIRECTORY / datainfo['dir'] / datainfo['catalog_directory']
    common.test_path(outpath_csv)

    #outfile_csv = datainfo['dir'] + '.csv'
    outfile_csv = out_file_stem + '.csv'
    outpath_csv = outpath_csv / outfile_csv

    df.to_csv(outpath_csv)
    common.out_file_message(outpath_csv)



    # Print the color map file. This will print a color for each unique taxon
    # ---------------------------------------------------------------------------
    outpath_cmap = Path.cwd() / datainfo['dir'] / datainfo['catalog_directory'] / common.SEQUENCE_DIRECTORY
    common.test_path(outpath_cmap)

    outfile_cmap = out_file_stem + '_taxon.cmap'
    outpath_cmap = outpath_cmap / outfile_cmap


    with open(outpath_cmap, 'wt') as cmap:

        header = common.header(datainfo, script_name=Path(__file__).name)
        print(header, file=cmap)

        # Print the number of colors
        print(f"{len(unique_taxons)}", file=cmap)

        # Print the initial "out of bounds" color
        #print("1.0 1.0 1.0 1.0 # White (out-of-bounds)", file=cmap)
        # Set the gray color for the zero-valued lineage points
        gray_color = ((str(common.GRAY_COLOR) + ' ') * 3) +  '1.0 # Gray | Used for zero or out-of-range value lineage codes'
        print(gray_color, file=cmap)

        for col, row in unique_taxons.iterrows():

            # Print the RGB
            print(f"{row['rgb']} 1.0 # {row['color_name']} | {row['taxon']} | {row['taxon_code']}", file=cmap)


    common.out_file_message(outpath_cmap)



    # # Print a log file
    # # ---------------------------------------------------------------------------
    # outfile_log = Path(__file__).name + '.log'
    # log_path = Path.cwd() / common.PROCESSED_DATA_DIRECTORY / datainfo['dir'] / common.LOG_DIRECTORY
    # common.test_path(log_path)

    # outpath_log = log_path / outfile_log

    # with open(outpath_log, 'wt') as log:


    #     print('Generated log from ' + Path(__file__).name + ' run with the ' + datainfo['dir'] + ' data set.', file=log)
    #     print('================================================================================', file=log)

    #     # Some general stats, number of rows
    #     print('Number of rows: ' + str(len(lineage_labels.index)), file=log)
    #     print('Number of columns: ' + str(len(lineage_labels.columns)), file=log)
    #     print(file=log)


    #     # Print all the column names
    #     print('The lineage_labels df:', file=log)
    #     print(pd.DataFrame({"column": lineage_labels.columns, "non-nulls": len(lineage_labels)-lineage_labels.isnull().sum().values, "nulls": lineage_labels.isnull().sum().values, "type": lineage_labels.dtypes.values}), file=log)
    #     print(file=log)


    # common.out_file_message(outpath_log)


    return df





def make_asset(datainfo):
    """
    Generate the asset file for the sequence data.

    :param datainfo: Metadata about the dataset.
    :type datainfo: dict of {str : list}

    Output files:
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    :file:`primates/{version}/sequences.asset`
        The asset file containing the OpenSpace configurations for the DNA sequence data.
    """

    # We shift the stdout to our filehandle so that we don't have to keep putting
    # the filehandle in every print statement.
    # Save the original stdout so we can switch back later
    original_stdout = sys.stdout


    # Define the main dict that will hold all the info needed per file
    # This is a nested dict with the format:
    #      { path: { root:  , filevar:  , os_variable:  , os_identifier:  , name:  } }
    asset_info = {}

    # Gather info about the files
    # Get a listing of the speck files in the path, then set the dict
    # values based on the filename.
    path = Path.cwd() / datainfo['dir'] / datainfo['catalog_directory'] / common.SEQUENCE_DIRECTORY
    files = sorted(path.glob('*.speck'))


    for path in files:
        
        file = path.name

        # Set the nested dict
        asset_info[file] = {}

        asset_info[file]['speck_file'] = path.name
        #print(asset_info[file]['speck_file'], path, path.name)
        asset_info[file]['speck_var'] = common.file_variable_generator(asset_info[file]['speck_file'])

        asset_info[file]['label_file'] = path.stem + '.label'
        asset_info[file]['label_var'] = common.file_variable_generator(asset_info[file]['label_file'])

        asset_info[file]['cmap_file'] = path.stem + '_taxon.cmap'
        asset_info[file]['cmap_var'] = common.file_variable_generator(asset_info[file]['cmap_file'])
        
        asset_info[file]['asset_rel_path'] = common.SEQUENCE_DIRECTORY

        asset_info[file]['os_scenegraph_var'] = datainfo['dir'] + '_' + datainfo['catalog_directory'] + '_' + path.stem
        asset_info[file]['os_identifier_var'] = datainfo['dir'] + '_' + datainfo['catalog_directory'] + '_' + path.stem

        asset_info[file]['gui_name'] = 'DNA ' + path.stem.replace('_', ' ').title()
        asset_info[file]['gui_path'] = '/' + datainfo['sub_project'] + '/' + datainfo['catalog_directory']



    # Open the file to write to
    outfile = common.SEQUENCE_DIRECTORY + '.asset'
    outpath = Path.cwd() / datainfo['dir'] / datainfo['catalog_directory'] / outfile
    with open(outpath, 'wt') as asset:

        # Switch stdout to the file
        sys.stdout = asset


        print('-- ' + datainfo['project'] + ' / ' + datainfo['data_group_title'])
        print("-- This file is auto-generated in the " + make_asset.__name__ + "() function inside " + Path(__file__).name)
        print('-- Author: Brian Abbott <abbott@amnh.org>')
        print()


        for file in asset_info:
            print('local ' + asset_info[file]['speck_var'] + ' = asset.localResource("' + asset_info[file]['asset_rel_path'] + '/' + asset_info[file]['speck_file'] + '")')

            #print('local ' + asset_info[file]['label_var'] + ' = asset.localResource("' + asset_info[file]['asset_rel_path'] + '/' + asset_info[file]['label_file'] + '")')

            print('local ' + asset_info[file]['cmap_var'] + ' = asset.localResource("' + asset_info[file]['asset_rel_path'] + '/' + asset_info[file]['cmap_file'] + '")')
        
            #print('local color_file = asset.localResource("' + asset_info[file]['cmap_file'] + '")')


        print('local texture_file = asset.localResource("point3A.png")')
        print()


        print('-- Set some parameters for OpenSpace settings')
        print('local scale_factor = ' + common.SCALE_FACTOR)
        print('local text_size = ' + common.TEXT_SIZE)
        print('local text_min_size = ' + common.TEXT_MIN_SIZE)
        print('local text_max_size = ' + common.TEXT_MAX_SIZE)
        print()



        for file in asset_info:

            print('local ' + asset_info[file]['os_scenegraph_var'] + ' = {')
            print('    Identifier = "' + asset_info[file]['os_identifier_var'] + '",')
            print('    Renderable = {')
            print('        Type = "RenderableCosmicPoints",')
            print('        Color = { 0.8, 0.8, 0.8 },')
            print('        ColorMap = ' + asset_info[file]['cmap_var'] + ',')
            print('        ColorOption = { "lineage_30_code", "taxon_code" },')
            print('        ColorRange = { {30001, 30025}, {1, 322} },')
            print('        Opacity = 1.0,')
            print('        ScaleFactor = scale_factor,')
            print('        File = ' + asset_info[file]['speck_var'] + ',')
            print('        DrawLabels = false,')
            print('        Unit = "Km",')
            print('        Texture = texture_file,')
            print('        BillboardMinMaxSize = { 0.0, 25.0 },')
            print('        EnablePixelSizeControl = true,')
            print('        EnableLabelFading = false,')
            print('        Enabled = false')
            print('    },')
            print('    GUI = {')
            print('        Name = "' + asset_info[file]['gui_name'] + '",')
            print('        Path = "' + asset_info[file]['gui_path'] + '",')
            print('    }')
            print('}')
            print()



        print('asset.onInitialize(function()')
        for file in asset_info:
            print('    openspace.addSceneGraphNode(' + asset_info[file]['os_scenegraph_var'] + ')')

        print('end)')
        print()


        print('asset.onDeinitialize(function()')
        for file in asset_info:
            print('    openspace.removeSceneGraphNode(' + asset_info[file]['os_scenegraph_var'] + ')')
        
        print('end)')
        print()


        for file in asset_info:
            print('asset.export(' + asset_info[file]['os_scenegraph_var'] + ')')

    # Switch the stdout back to normal stdout (screen)
    sys.stdout = original_stdout

 
    # Report to stdout
    common.out_file_message(outpath)
    print()
